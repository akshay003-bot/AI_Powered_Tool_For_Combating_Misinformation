!pip install scikit-learn joblib
import re
import joblib
import pandas as pd
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score
from sklearn.pipeline import Pipeline
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.feature_extraction.text import TfidfVectorizer

from sklearn.ensemble import RandomForestClassifier, StackingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import MultinomialNB
from sklearn.svm import LinearSVC
from sklearn.calibration import CalibratedClassifierCV

#text cleaner
class SimpleTextCleaner(BaseEstimator, TransformerMixin):
    def __init__(self, lower=True, strip_html=True, remove_urls=True, remove_emails=True):
        self.lower = lower
        self.strip_html = strip_html
        self.remove_urls = remove_urls
        self.remove_emails = remove_emails
        self._html = re.compile(r"<.*?>")
        self._url = re.compile(r"https?://\S+|www\.\S+")
        self._email = re.compile(r"\b[\w\.-]+?@[\w\.-]+\.\w+\b")

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        cleaned = []
        for t in X:
            if pd.isna(t):
                t = ""
            s = str(t)
            if self.lower: s = s.lower()
            if self.strip_html: s = self._html.sub(" ", s)
            if self.remove_urls: s = self._url.sub(" ", s)
            if self.remove_emails: s = self._email.sub(" ", s)
            s = re.sub(r"\s+", " ", s).strip()
            cleaned.append(s)
        return cleaned

#label
def coerce_labels(y: pd.Series) -> np.ndarray:
    mapping = {
        "phishing": 1, "spam": 1, "malicious": 1, "fraud": 1, "1": 1, "yes": 1, "true": 1,
        "legitimate": 0, "ham": 0, "benign": 0, "0": 0, "no": 0, "false": 0
    }
    def to01(v):
        s = str(v).strip().lower()
        if s in mapping:
            return mapping[s]
        try:
            return 1 if int(float(s)) > 0 else 0
        except:
            return 0
    return y.map(to01).astype(int).values


#models
def build_rf_pipeline(max_features=50000):
    return Pipeline([
        ("clean", SimpleTextCleaner()),
        ("tfidf", TfidfVectorizer(ngram_range=(1,2), max_features=max_features,
                                  min_df=2, stop_words="english")),
        ("clf", RandomForestClassifier(n_estimators=400, class_weight="balanced",
                                       n_jobs=-1, random_state=42))
    ])

def build_stacked_pipeline(max_features=50000):
    base_lr = LogisticRegression(max_iter=2000, class_weight="balanced", solver="liblinear")
    base_svc = CalibratedClassifierCV(
        estimator=LinearSVC(class_weight="balanced", random_state=42), # Changed from base_estimator to estimator
        method="sigmoid", cv=3
    )
    base_nb = MultinomialNB(alpha=0.5)

    stack = StackingClassifier(
        estimators=[("lr", base_lr), ("svm", base_svc), ("nb", base_nb)],
        final_estimator=LogisticRegression(max_iter=2000, class_weight="balanced", solver="liblinear"),
        cv=5, n_jobs=-1
    )

#train and evaluate

import pandas as pd
df = pd.read_csv("Phishing_Email.csv")

# Use correct columns
text_col = "Email Text"
label_col = "Email Type"

X = df[text_col].astype(str).fillna("")
y_raw = df[label_col]

def coerce_labels(y):
    return y.map(lambda v: 1 if "phishing" in str(v).lower() else 0).astype(int)

y = coerce_labels(y_raw)


from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, stratify=y, random_state=42
)

model = build_stacked_pipeline()  
model.fit(X_train, y_train)

from sklearn.metrics import classification_report, confusion_matrix

y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred, digits=4))
print(confusion_matrix(y_test, y_pred))


#function for checking
def check_mail(email_text):
    """
    Check if an email is phishing or safe.
    Input: single email text (string)
    Output: prediction + probabilities
    """
    X_live = pd.Series([email_text])  # wrap as Series for pipeline
    pred_label = model.predict(X_live)[0]
    pred_prob = model.predict_proba(X_live)[0]

    print("\nEmail:", email_text)
    print("Predicted:", "Phishing" if pred_label == 1 else "Safe")
    print(f"Phishing probability: {pred_prob[1]:.4f}")
    print(f"Safe probability: {pred_prob[0]:.4f}")
